<!doctype html>
<html>
  <head>
    <title>C++ Projects</title>
  </head>
  <body>
    <ul>
      <li>
	<a href="https://github.com/sureshyhap/Data-Structures-and-Algorithms-I/blob/master/Second/Project%201/stacks_and_queues.cpp">Stacks and Queues</a>
	<p>
	  Implemented Stack and Queue classes from a List class (made by me not std::list) using the major OOP concepts of Encapsulation, Information Hiding, Inheritance, and Polymorphism. My list class was called SimpleList and was an Abstract Base Class. From it I derived several stacks and queues. I used std::list to contain pointers to general SimpleLists that were stacks and queues. By making the functions push and pop virtual, when using the pointers to call push and pop, the correct version was called depending on whether the SimpleList pointer pointed to a stack or a queue.
	</p>
      </li>
      <li>
	<a href="https://github.com/sureshyhap/Data-Structures-and-Algorithms-I/blob/master/Second/Project%202/fastest_sort.cpp">Fastest Sort</a>
	<p>
	  Attempted to make the fastest possible sort for different data sets with different characteristics. The data were people’s last and first names along with social-security numbers. It wasn’t simply the case that Quick Sort would be the fastest for all of them. Knowledge of other sorts and their computational complexities were important. I ended up using Merge Sort for the smallest general data sets of 100,000 people, Quick Sort for data similar to the smallest but with 1,000,000 people, Insertion Sort for data that was close to sorted, and Least-Significant Digit Radix Sort for the final data set where the names didn’t matter and only the social-security numbers were being sorted (they were treated as integers). This shows that even Insertion Sort can have practical application and the linear worst case Big-Oh running time of LSD Radix sort can make it faster than even Quick Sort for sorting integers.
	</p>
      </li>
      <li>
	<a href="https://github.com/sureshyhap/Data-Structures-and-Algorithms-II/tree/master/Second/Project%201">Hash Table</a>
	<p>
	  Implemented a hash table used to spell check a document based on a dictionary of valid words inserted into the hash table
	</p>
      </li>
      <li>
	<a href="https://github.com/sureshyhap/Data-Structures-and-Algorithms-II/tree/master/Second/Project%202">Priority Queue</a>
	<p>
	  Implemented a priority queue using a binary heap implementation. Uses the previous hash table class to map a string id to a heap node for quick access.
	</p>
      </li>
      <li>
	<a href="https://github.com/sureshyhap/Data-Structures-and-Algorithms-II/tree/master/Second/Project%203">Graphs and Dijkstra's Algorithm</a>
	<p>
	  Implemented Dijkstra’s algorithm to solve the single source shortest path problem. It finds the path of least cost from a given starting node to all other nodes in the graph. Uses the previous priority queue to quickly access the node with shortest path cost so far. Also uses the hash table class indirectly through the priority queue and directly to reach a given graph node.
	</p>
      </li>      
    </ul>
  </body>
</html>
